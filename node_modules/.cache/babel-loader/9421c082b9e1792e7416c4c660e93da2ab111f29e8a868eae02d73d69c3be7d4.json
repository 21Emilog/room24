{"ast":null,"code":"import _objectSpread from \"C:/Users/kutum/Documents/room-rental-platform/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { transformToViewState, applyViewStateToTransform } from \"../utils/transform.js\";\nimport { normalizeStyle } from \"../utils/style-utils.js\";\nimport { deepEqual } from \"../utils/deep-equal.js\";\nconst DEFAULT_STYLE = {\n  version: 8,\n  sources: {},\n  layers: []\n};\nconst pointerEvents = {\n  mousedown: 'onMouseDown',\n  mouseup: 'onMouseUp',\n  mouseover: 'onMouseOver',\n  mousemove: 'onMouseMove',\n  click: 'onClick',\n  dblclick: 'onDblClick',\n  mouseenter: 'onMouseEnter',\n  mouseleave: 'onMouseLeave',\n  mouseout: 'onMouseOut',\n  contextmenu: 'onContextMenu',\n  touchstart: 'onTouchStart',\n  touchend: 'onTouchEnd',\n  touchmove: 'onTouchMove',\n  touchcancel: 'onTouchCancel'\n};\nconst cameraEvents = {\n  movestart: 'onMoveStart',\n  move: 'onMove',\n  moveend: 'onMoveEnd',\n  dragstart: 'onDragStart',\n  drag: 'onDrag',\n  dragend: 'onDragEnd',\n  zoomstart: 'onZoomStart',\n  zoom: 'onZoom',\n  zoomend: 'onZoomEnd',\n  rotatestart: 'onRotateStart',\n  rotate: 'onRotate',\n  rotateend: 'onRotateEnd',\n  pitchstart: 'onPitchStart',\n  pitch: 'onPitch',\n  pitchend: 'onPitchEnd'\n};\nconst otherEvents = {\n  wheel: 'onWheel',\n  boxzoomstart: 'onBoxZoomStart',\n  boxzoomend: 'onBoxZoomEnd',\n  boxzoomcancel: 'onBoxZoomCancel',\n  resize: 'onResize',\n  load: 'onLoad',\n  render: 'onRender',\n  idle: 'onIdle',\n  remove: 'onRemove',\n  data: 'onData',\n  styledata: 'onStyleData',\n  sourcedata: 'onSourceData',\n  error: 'onError'\n};\nconst settingNames = ['minZoom', 'maxZoom', 'minPitch', 'maxPitch', 'maxBounds', 'projection', 'renderWorldCopies'];\nconst handlerNames = ['scrollZoom', 'boxZoom', 'dragRotate', 'dragPan', 'keyboard', 'doubleClickZoom', 'touchZoomRotate', 'touchPitch'];\n/**\n * A wrapper for mapbox-gl's Map class\n */\nclass Maplibre {\n  constructor(MapClass, props, container) {\n    // mapboxgl.Map instance\n    this._map = null;\n    // Internal states\n    this._internalUpdate = false;\n    this._hoveredFeatures = null;\n    this._propsedCameraUpdate = null;\n    this._styleComponents = {};\n    this._onEvent = e => {\n      // @ts-ignore\n      const cb = this.props[otherEvents[e.type]];\n      if (cb) {\n        cb(e);\n      } else if (e.type === 'error') {\n        console.error(e.error); // eslint-disable-line\n      }\n    };\n    this._onCameraEvent = e => {\n      if (this._internalUpdate) {\n        return;\n      }\n      e.viewState = this._propsedCameraUpdate || transformToViewState(this._map.transform);\n      // @ts-ignore\n      const cb = this.props[cameraEvents[e.type]];\n      if (cb) {\n        cb(e);\n      }\n    };\n    this._onCameraUpdate = tr => {\n      if (this._internalUpdate) {\n        return tr;\n      }\n      this._propsedCameraUpdate = transformToViewState(tr);\n      return applyViewStateToTransform(tr, this.props);\n    };\n    this._onPointerEvent = e => {\n      if (e.type === 'mousemove' || e.type === 'mouseout') {\n        this._updateHover(e);\n      }\n      // @ts-ignore\n      const cb = this.props[pointerEvents[e.type]];\n      if (cb) {\n        if (this.props.interactiveLayerIds && e.type !== 'mouseover' && e.type !== 'mouseout') {\n          e.features = this._hoveredFeatures || this._queryRenderedFeatures(e.point);\n        }\n        cb(e);\n        delete e.features;\n      }\n    };\n    this._MapClass = MapClass;\n    this.props = props;\n    this._initialize(container);\n  }\n  get map() {\n    return this._map;\n  }\n  setProps(props) {\n    const oldProps = this.props;\n    this.props = props;\n    const settingsChanged = this._updateSettings(props, oldProps);\n    const sizeChanged = this._updateSize(props);\n    const viewStateChanged = this._updateViewState(props);\n    this._updateStyle(props, oldProps);\n    this._updateStyleComponents(props);\n    this._updateHandlers(props, oldProps);\n    // If 1) view state has changed to match props and\n    //    2) the props change is not triggered by map events,\n    // it's driven by an external state change. Redraw immediately\n    if (settingsChanged || sizeChanged || viewStateChanged && !this._map.isMoving()) {\n      this.redraw();\n    }\n  }\n  static reuse(props, container) {\n    const that = Maplibre.savedMaps.pop();\n    if (!that) {\n      return null;\n    }\n    const map = that.map;\n    // When reusing the saved map, we need to reparent the map(canvas) and other child nodes\n    // intoto the new container from the props.\n    // Step 1: reparenting child nodes from old container to new container\n    const oldContainer = map.getContainer();\n    container.className = oldContainer.className;\n    while (oldContainer.childNodes.length > 0) {\n      container.appendChild(oldContainer.childNodes[0]);\n    }\n    // Step 2: replace the internal container with new container from the react component\n    // @ts-ignore\n    map._container = container;\n    // With maplibre-gl as mapLib, map uses ResizeObserver to observe when its container resizes.\n    // When reusing the saved map, we need to disconnect the observer and observe the new container.\n    // Step 3: telling the ResizeObserver to disconnect and observe the new container\n    // @ts-ignore\n    const resizeObserver = map._resizeObserver;\n    if (resizeObserver) {\n      resizeObserver.disconnect();\n      resizeObserver.observe(container);\n    }\n    // Step 4: apply new props\n    that.setProps(_objectSpread(_objectSpread({}, props), {}, {\n      styleDiffing: false\n    }));\n    map.resize();\n    const {\n      initialViewState\n    } = props;\n    if (initialViewState) {\n      if (initialViewState.bounds) {\n        map.fitBounds(initialViewState.bounds, _objectSpread(_objectSpread({}, initialViewState.fitBoundsOptions), {}, {\n          duration: 0\n        }));\n      } else {\n        that._updateViewState(initialViewState);\n      }\n    }\n    // Simulate load event\n    if (map.isStyleLoaded()) {\n      map.fire('load');\n    } else {\n      map.once('style.load', () => map.fire('load'));\n    }\n    // Force reload\n    // @ts-ignore\n    map._update();\n    return that;\n  }\n  /* eslint-disable complexity,max-statements */\n  _initialize(container) {\n    const {\n      props\n    } = this;\n    const {\n      mapStyle = DEFAULT_STYLE\n    } = props;\n    const mapOptions = _objectSpread(_objectSpread(_objectSpread({}, props), props.initialViewState), {}, {\n      container,\n      style: normalizeStyle(mapStyle)\n    });\n    const viewState = mapOptions.initialViewState || mapOptions.viewState || mapOptions;\n    Object.assign(mapOptions, {\n      center: [viewState.longitude || 0, viewState.latitude || 0],\n      zoom: viewState.zoom || 0,\n      pitch: viewState.pitch || 0,\n      bearing: viewState.bearing || 0\n    });\n    if (props.gl) {\n      // eslint-disable-next-line\n      const getContext = HTMLCanvasElement.prototype.getContext;\n      // Hijack canvas.getContext to return our own WebGLContext\n      // This will be called inside the mapboxgl.Map constructor\n      // @ts-expect-error\n      HTMLCanvasElement.prototype.getContext = () => {\n        // Unhijack immediately\n        HTMLCanvasElement.prototype.getContext = getContext;\n        return props.gl;\n      };\n    }\n    const map = new this._MapClass(mapOptions);\n    // Props that are not part of constructor options\n    if (viewState.padding) {\n      map.setPadding(viewState.padding);\n    }\n    if (props.cursor) {\n      map.getCanvas().style.cursor = props.cursor;\n    }\n    // add listeners\n    map.transformCameraUpdate = this._onCameraUpdate;\n    map.on('style.load', () => {\n      var _map$getProjection;\n      // Map style has changed, this would have wiped out all settings from props\n      this._styleComponents = {\n        light: map.getLight(),\n        sky: map.getSky(),\n        // @ts-ignore getProjection() does not exist in v4\n        projection: (_map$getProjection = map.getProjection) === null || _map$getProjection === void 0 ? void 0 : _map$getProjection.call(map),\n        terrain: map.getTerrain()\n      };\n      this._updateStyleComponents(this.props);\n    });\n    map.on('sourcedata', () => {\n      // Some sources have loaded, we may need them to attach terrain\n      this._updateStyleComponents(this.props);\n    });\n    for (const eventName in pointerEvents) {\n      map.on(eventName, this._onPointerEvent);\n    }\n    for (const eventName in cameraEvents) {\n      map.on(eventName, this._onCameraEvent);\n    }\n    for (const eventName in otherEvents) {\n      map.on(eventName, this._onEvent);\n    }\n    this._map = map;\n  }\n  /* eslint-enable complexity,max-statements */\n  recycle() {\n    // Clean up unnecessary elements before storing for reuse.\n    const container = this.map.getContainer();\n    const children = container.querySelector('[mapboxgl-children]');\n    children === null || children === void 0 || children.remove();\n    Maplibre.savedMaps.push(this);\n  }\n  destroy() {\n    this._map.remove();\n  }\n  // Force redraw the map now. Typically resize() and jumpTo() is reflected in the next\n  // render cycle, which is managed by Mapbox's animation loop.\n  // This removes the synchronization issue caused by requestAnimationFrame.\n  redraw() {\n    const map = this._map;\n    // map._render will throw error if style does not exist\n    // https://github.com/mapbox/mapbox-gl-js/blob/fb9fc316da14e99ff4368f3e4faa3888fb43c513\n    //   /src/ui/map.js#L1834\n    if (map.style) {\n      // cancel the scheduled update\n      if (map._frame) {\n        map._frame.cancel();\n        map._frame = null;\n      }\n      // the order is important - render() may schedule another update\n      map._render();\n    }\n  }\n  /* Trigger map resize if size is controlled\n     @param {object} nextProps\n     @returns {bool} true if size has changed\n   */\n  _updateSize(nextProps) {\n    // Check if size is controlled\n    const {\n      viewState\n    } = nextProps;\n    if (viewState) {\n      const map = this._map;\n      if (viewState.width !== map.transform.width || viewState.height !== map.transform.height) {\n        map.resize();\n        return true;\n      }\n    }\n    return false;\n  }\n  // Adapted from map.jumpTo\n  /* Update camera to match props\n     @param {object} nextProps\n     @param {bool} triggerEvents - should fire camera events\n     @returns {bool} true if anything is changed\n   */\n  _updateViewState(nextProps) {\n    const map = this._map;\n    const tr = map.transform;\n    const isMoving = map.isMoving();\n    // Avoid manipulating the real transform when interaction/animation is ongoing\n    // as it would interfere with Mapbox's handlers\n    if (!isMoving) {\n      const changes = applyViewStateToTransform(tr, nextProps);\n      if (Object.keys(changes).length > 0) {\n        this._internalUpdate = true;\n        map.jumpTo(changes);\n        this._internalUpdate = false;\n        return true;\n      }\n    }\n    return false;\n  }\n  /* Update camera constraints and projection settings to match props\n     @param {object} nextProps\n     @param {object} currProps\n     @returns {bool} true if anything is changed\n   */\n  _updateSettings(nextProps, currProps) {\n    const map = this._map;\n    let changed = false;\n    for (const propName of settingNames) {\n      if (propName in nextProps && !deepEqual(nextProps[propName], currProps[propName])) {\n        changed = true;\n        const setter = map[\"set\".concat(propName[0].toUpperCase()).concat(propName.slice(1))];\n        setter === null || setter === void 0 || setter.call(map, nextProps[propName]);\n      }\n    }\n    return changed;\n  }\n  /* Update map style to match props */\n  _updateStyle(nextProps, currProps) {\n    if (nextProps.cursor !== currProps.cursor) {\n      this._map.getCanvas().style.cursor = nextProps.cursor || '';\n    }\n    if (nextProps.mapStyle !== currProps.mapStyle) {\n      const {\n        mapStyle = DEFAULT_STYLE,\n        styleDiffing = true\n      } = nextProps;\n      const options = {\n        diff: styleDiffing\n      };\n      if ('localIdeographFontFamily' in nextProps) {\n        // @ts-ignore Mapbox specific prop\n        options.localIdeographFontFamily = nextProps.localIdeographFontFamily;\n      }\n      this._map.setStyle(normalizeStyle(mapStyle), options);\n    }\n  }\n  /* Update fog, light, projection and terrain to match props\n   * These props are special because\n   * 1. They can not be applied right away. Certain conditions (style loaded, source loaded, etc.) must be met\n   * 2. They can be overwritten by mapStyle\n   */\n  _updateStyleComponents(_ref) {\n    let {\n      light,\n      projection,\n      sky,\n      terrain\n    } = _ref;\n    const map = this._map;\n    const currProps = this._styleComponents;\n    // We can safely manipulate map style once it's loaded\n    if (map.style._loaded) {\n      var _currProps$projection;\n      if (light && !deepEqual(light, currProps.light)) {\n        currProps.light = light;\n        map.setLight(light);\n      }\n      if (projection && !deepEqual(projection, currProps.projection) && projection !== ((_currProps$projection = currProps.projection) === null || _currProps$projection === void 0 ? void 0 : _currProps$projection.type)) {\n        var _map$setProjection;\n        currProps.projection = typeof projection === 'string' ? {\n          type: projection\n        } : projection;\n        // @ts-ignore setProjection does not exist in v4\n        (_map$setProjection = map.setProjection) === null || _map$setProjection === void 0 || _map$setProjection.call(map, currProps.projection);\n      }\n      if (sky && !deepEqual(sky, currProps.sky)) {\n        currProps.sky = sky;\n        map.setSky(sky);\n      }\n      if (terrain !== undefined && !deepEqual(terrain, currProps.terrain)) {\n        if (!terrain || map.getSource(terrain.source)) {\n          currProps.terrain = terrain;\n          map.setTerrain(terrain);\n        }\n      }\n    }\n  }\n  /* Update interaction handlers to match props */\n  _updateHandlers(nextProps, currProps) {\n    const map = this._map;\n    for (const propName of handlerNames) {\n      var _nextProps$propName, _currProps$propName;\n      const newValue = (_nextProps$propName = nextProps[propName]) !== null && _nextProps$propName !== void 0 ? _nextProps$propName : true;\n      const oldValue = (_currProps$propName = currProps[propName]) !== null && _currProps$propName !== void 0 ? _currProps$propName : true;\n      if (!deepEqual(newValue, oldValue)) {\n        if (newValue) {\n          map[propName].enable(newValue);\n        } else {\n          map[propName].disable();\n        }\n      }\n    }\n  }\n  _queryRenderedFeatures(point) {\n    const map = this._map;\n    const {\n      interactiveLayerIds = []\n    } = this.props;\n    try {\n      return map.queryRenderedFeatures(point, {\n        layers: interactiveLayerIds.filter(map.getLayer.bind(map))\n      });\n    } catch (_unused) {\n      // May fail if style is not loaded\n      return [];\n    }\n  }\n  _updateHover(e) {\n    const {\n      props\n    } = this;\n    const shouldTrackHoveredFeatures = props.interactiveLayerIds && (props.onMouseMove || props.onMouseEnter || props.onMouseLeave);\n    if (shouldTrackHoveredFeatures) {\n      var _this$_hoveredFeature;\n      const eventType = e.type;\n      const wasHovering = ((_this$_hoveredFeature = this._hoveredFeatures) === null || _this$_hoveredFeature === void 0 ? void 0 : _this$_hoveredFeature.length) > 0;\n      const features = this._queryRenderedFeatures(e.point);\n      const isHovering = features.length > 0;\n      if (!isHovering && wasHovering) {\n        e.type = 'mouseleave';\n        this._onPointerEvent(e);\n      }\n      this._hoveredFeatures = features;\n      if (isHovering && !wasHovering) {\n        e.type = 'mouseenter';\n        this._onPointerEvent(e);\n      }\n      e.type = eventType;\n    } else {\n      this._hoveredFeatures = null;\n    }\n  }\n}\nMaplibre.savedMaps = [];\nexport default Maplibre;","map":{"version":3,"names":["transformToViewState","applyViewStateToTransform","normalizeStyle","deepEqual","DEFAULT_STYLE","version","sources","layers","pointerEvents","mousedown","mouseup","mouseover","mousemove","click","dblclick","mouseenter","mouseleave","mouseout","contextmenu","touchstart","touchend","touchmove","touchcancel","cameraEvents","movestart","move","moveend","dragstart","drag","dragend","zoomstart","zoom","zoomend","rotatestart","rotate","rotateend","pitchstart","pitch","pitchend","otherEvents","wheel","boxzoomstart","boxzoomend","boxzoomcancel","resize","load","render","idle","remove","data","styledata","sourcedata","error","settingNames","handlerNames","Maplibre","constructor","MapClass","props","container","_map","_internalUpdate","_hoveredFeatures","_propsedCameraUpdate","_styleComponents","_onEvent","e","cb","type","console","_onCameraEvent","viewState","transform","_onCameraUpdate","tr","_onPointerEvent","_updateHover","interactiveLayerIds","features","_queryRenderedFeatures","point","_MapClass","_initialize","map","setProps","oldProps","settingsChanged","_updateSettings","sizeChanged","_updateSize","viewStateChanged","_updateViewState","_updateStyle","_updateStyleComponents","_updateHandlers","isMoving","redraw","reuse","that","savedMaps","pop","oldContainer","getContainer","className","childNodes","length","appendChild","_container","resizeObserver","_resizeObserver","disconnect","observe","_objectSpread","styleDiffing","initialViewState","bounds","fitBounds","fitBoundsOptions","duration","isStyleLoaded","fire","once","_update","mapStyle","mapOptions","style","Object","assign","center","longitude","latitude","bearing","gl","getContext","HTMLCanvasElement","prototype","padding","setPadding","cursor","getCanvas","transformCameraUpdate","on","_map$getProjection","light","getLight","sky","getSky","projection","getProjection","call","terrain","getTerrain","eventName","recycle","children","querySelector","push","destroy","_frame","cancel","_render","nextProps","width","height","changes","keys","jumpTo","currProps","changed","propName","setter","concat","toUpperCase","slice","options","diff","localIdeographFontFamily","setStyle","_ref","_loaded","_currProps$projection","setLight","_map$setProjection","setProjection","setSky","undefined","getSource","source","setTerrain","_nextProps$propName","_currProps$propName","newValue","oldValue","enable","disable","queryRenderedFeatures","filter","getLayer","bind","_unused","shouldTrackHoveredFeatures","onMouseMove","onMouseEnter","onMouseLeave","_this$_hoveredFeature","eventType","wasHovering","isHovering"],"sources":["C:\\Users\\kutum\\Documents\\room-rental-platform\\node_modules\\@vis.gl\\react-maplibre\\src\\maplibre\\maplibre.ts"],"sourcesContent":["import {transformToViewState, applyViewStateToTransform} from '../utils/transform';\nimport {normalizeStyle} from '../utils/style-utils';\nimport {deepEqual} from '../utils/deep-equal';\n\nimport type {TransformLike} from '../types/internal';\nimport type {\n  ViewState,\n  Point,\n  PointLike,\n  PaddingOptions,\n  ImmutableLike,\n  LngLatBoundsLike,\n  MapGeoJSONFeature\n} from '../types/common';\nimport type {\n  StyleSpecification,\n  SkySpecification,\n  LightSpecification,\n  TerrainSpecification,\n  ProjectionSpecification\n} from '../types/style-spec';\nimport type {MapInstance} from '../types/lib';\nimport type {\n  MapCallbacks,\n  ViewStateChangeEvent,\n  MapEvent,\n  ErrorEvent,\n  MapMouseEvent\n} from '../types/events';\n\nexport type MaplibreProps = Partial<ViewState> &\n  MapCallbacks & {\n    /** Camera options used when constructing the Map instance */\n    initialViewState?: Partial<ViewState> & {\n      /** The initial bounds of the map. If bounds is specified, it overrides longitude, latitude and zoom options. */\n      bounds?: LngLatBoundsLike;\n      /** A fitBounds options object to use only when setting the bounds option. */\n      fitBoundsOptions?: {\n        offset?: PointLike;\n        minZoom?: number;\n        maxZoom?: number;\n        padding?: number | PaddingOptions;\n      };\n    };\n\n    /** If provided, render into an external WebGL context */\n    gl?: WebGLRenderingContext;\n\n    /** For external controller to override the camera state */\n    viewState?: ViewState & {\n      width: number;\n      height: number;\n    };\n\n    // Styling\n\n    /** Mapbox style */\n    mapStyle?: string | StyleSpecification | ImmutableLike<StyleSpecification>;\n    /** Enable diffing when the map style changes\n     * @default true\n     */\n    styleDiffing?: boolean;\n    /** The projection property of the style. Must conform to the Projection Style Specification.\n     * @default 'mercator'\n     */\n    projection?: ProjectionSpecification | 'mercator' | 'globe';\n    /** Light properties of the map. */\n    light?: LightSpecification;\n    /** Terrain property of the style. Must conform to the Terrain Style Specification.\n     * If `undefined` is provided, removes terrain from the map. */\n    terrain?: TerrainSpecification;\n    /** Sky properties of the map. Must conform to the Sky Style Specification. */\n    sky?: SkySpecification;\n\n    /** Default layers to query on pointer events */\n    interactiveLayerIds?: string[];\n    /** CSS cursor */\n    cursor?: string;\n  };\n\nconst DEFAULT_STYLE = {version: 8, sources: {}, layers: []} as StyleSpecification;\n\nconst pointerEvents = {\n  mousedown: 'onMouseDown',\n  mouseup: 'onMouseUp',\n  mouseover: 'onMouseOver',\n  mousemove: 'onMouseMove',\n  click: 'onClick',\n  dblclick: 'onDblClick',\n  mouseenter: 'onMouseEnter',\n  mouseleave: 'onMouseLeave',\n  mouseout: 'onMouseOut',\n  contextmenu: 'onContextMenu',\n  touchstart: 'onTouchStart',\n  touchend: 'onTouchEnd',\n  touchmove: 'onTouchMove',\n  touchcancel: 'onTouchCancel'\n};\nconst cameraEvents = {\n  movestart: 'onMoveStart',\n  move: 'onMove',\n  moveend: 'onMoveEnd',\n  dragstart: 'onDragStart',\n  drag: 'onDrag',\n  dragend: 'onDragEnd',\n  zoomstart: 'onZoomStart',\n  zoom: 'onZoom',\n  zoomend: 'onZoomEnd',\n  rotatestart: 'onRotateStart',\n  rotate: 'onRotate',\n  rotateend: 'onRotateEnd',\n  pitchstart: 'onPitchStart',\n  pitch: 'onPitch',\n  pitchend: 'onPitchEnd'\n};\nconst otherEvents = {\n  wheel: 'onWheel',\n  boxzoomstart: 'onBoxZoomStart',\n  boxzoomend: 'onBoxZoomEnd',\n  boxzoomcancel: 'onBoxZoomCancel',\n  resize: 'onResize',\n  load: 'onLoad',\n  render: 'onRender',\n  idle: 'onIdle',\n  remove: 'onRemove',\n  data: 'onData',\n  styledata: 'onStyleData',\n  sourcedata: 'onSourceData',\n  error: 'onError'\n};\nconst settingNames = [\n  'minZoom',\n  'maxZoom',\n  'minPitch',\n  'maxPitch',\n  'maxBounds',\n  'projection',\n  'renderWorldCopies'\n];\nconst handlerNames = [\n  'scrollZoom',\n  'boxZoom',\n  'dragRotate',\n  'dragPan',\n  'keyboard',\n  'doubleClickZoom',\n  'touchZoomRotate',\n  'touchPitch'\n];\n\n/**\n * A wrapper for mapbox-gl's Map class\n */\nexport default class Maplibre {\n  private _MapClass: {new (options: any): MapInstance};\n  // mapboxgl.Map instance\n  private _map: MapInstance = null;\n  // User-supplied props\n  props: MaplibreProps;\n\n  // Internal states\n  private _internalUpdate: boolean = false;\n  private _hoveredFeatures: MapGeoJSONFeature[] = null;\n  private _propsedCameraUpdate: ViewState | null = null;\n  private _styleComponents: {\n    light?: LightSpecification;\n    sky?: SkySpecification;\n    projection?: ProjectionSpecification;\n    terrain?: TerrainSpecification | null;\n  } = {};\n\n  static savedMaps: Maplibre[] = [];\n\n  constructor(\n    MapClass: {new (options: any): MapInstance},\n    props: MaplibreProps,\n    container: HTMLDivElement\n  ) {\n    this._MapClass = MapClass;\n    this.props = props;\n    this._initialize(container);\n  }\n\n  get map(): MapInstance {\n    return this._map;\n  }\n\n  setProps(props: MaplibreProps) {\n    const oldProps = this.props;\n    this.props = props;\n\n    const settingsChanged = this._updateSettings(props, oldProps);\n    const sizeChanged = this._updateSize(props);\n    const viewStateChanged = this._updateViewState(props);\n    this._updateStyle(props, oldProps);\n    this._updateStyleComponents(props);\n    this._updateHandlers(props, oldProps);\n\n    // If 1) view state has changed to match props and\n    //    2) the props change is not triggered by map events,\n    // it's driven by an external state change. Redraw immediately\n    if (settingsChanged || sizeChanged || (viewStateChanged && !this._map.isMoving())) {\n      this.redraw();\n    }\n  }\n\n  static reuse(props: MaplibreProps, container: HTMLDivElement): Maplibre {\n    const that = Maplibre.savedMaps.pop();\n    if (!that) {\n      return null;\n    }\n\n    const map = that.map;\n    // When reusing the saved map, we need to reparent the map(canvas) and other child nodes\n    // intoto the new container from the props.\n    // Step 1: reparenting child nodes from old container to new container\n    const oldContainer = map.getContainer();\n    container.className = oldContainer.className;\n    while (oldContainer.childNodes.length > 0) {\n      container.appendChild(oldContainer.childNodes[0]);\n    }\n    // Step 2: replace the internal container with new container from the react component\n    // @ts-ignore\n    map._container = container;\n\n    // With maplibre-gl as mapLib, map uses ResizeObserver to observe when its container resizes.\n    // When reusing the saved map, we need to disconnect the observer and observe the new container.\n    // Step 3: telling the ResizeObserver to disconnect and observe the new container\n    // @ts-ignore\n    const resizeObserver = map._resizeObserver;\n    if (resizeObserver) {\n      resizeObserver.disconnect();\n      resizeObserver.observe(container);\n    }\n\n    // Step 4: apply new props\n    that.setProps({...props, styleDiffing: false});\n    map.resize();\n    const {initialViewState} = props;\n    if (initialViewState) {\n      if (initialViewState.bounds) {\n        map.fitBounds(initialViewState.bounds, {...initialViewState.fitBoundsOptions, duration: 0});\n      } else {\n        that._updateViewState(initialViewState);\n      }\n    }\n\n    // Simulate load event\n    if (map.isStyleLoaded()) {\n      map.fire('load');\n    } else {\n      map.once('style.load', () => map.fire('load'));\n    }\n\n    // Force reload\n    // @ts-ignore\n    map._update();\n    return that;\n  }\n\n  /* eslint-disable complexity,max-statements */\n  private _initialize(container: HTMLDivElement) {\n    const {props} = this;\n    const {mapStyle = DEFAULT_STYLE} = props;\n    const mapOptions = {\n      ...props,\n      ...props.initialViewState,\n      container,\n      style: normalizeStyle(mapStyle)\n    };\n\n    const viewState = mapOptions.initialViewState || mapOptions.viewState || mapOptions;\n    Object.assign(mapOptions, {\n      center: [viewState.longitude || 0, viewState.latitude || 0],\n      zoom: viewState.zoom || 0,\n      pitch: viewState.pitch || 0,\n      bearing: viewState.bearing || 0\n    });\n\n    if (props.gl) {\n      // eslint-disable-next-line\n      const getContext = HTMLCanvasElement.prototype.getContext;\n      // Hijack canvas.getContext to return our own WebGLContext\n      // This will be called inside the mapboxgl.Map constructor\n      // @ts-expect-error\n      HTMLCanvasElement.prototype.getContext = () => {\n        // Unhijack immediately\n        HTMLCanvasElement.prototype.getContext = getContext;\n        return props.gl;\n      };\n    }\n\n    const map = new this._MapClass(mapOptions);\n    // Props that are not part of constructor options\n    if (viewState.padding) {\n      map.setPadding(viewState.padding);\n    }\n    if (props.cursor) {\n      map.getCanvas().style.cursor = props.cursor;\n    }\n\n    // add listeners\n    map.transformCameraUpdate = this._onCameraUpdate;\n    map.on('style.load', () => {\n      // Map style has changed, this would have wiped out all settings from props\n      this._styleComponents = {\n        light: map.getLight(),\n        sky: map.getSky(),\n        // @ts-ignore getProjection() does not exist in v4\n        projection: map.getProjection?.(),\n        terrain: map.getTerrain()\n      };\n      this._updateStyleComponents(this.props);\n    });\n    map.on('sourcedata', () => {\n      // Some sources have loaded, we may need them to attach terrain\n      this._updateStyleComponents(this.props);\n    });\n    for (const eventName in pointerEvents) {\n      map.on(eventName, this._onPointerEvent);\n    }\n    for (const eventName in cameraEvents) {\n      map.on(eventName, this._onCameraEvent);\n    }\n    for (const eventName in otherEvents) {\n      map.on(eventName, this._onEvent);\n    }\n    this._map = map;\n  }\n  /* eslint-enable complexity,max-statements */\n\n  recycle() {\n    // Clean up unnecessary elements before storing for reuse.\n    const container = this.map.getContainer();\n    const children = container.querySelector('[mapboxgl-children]');\n    children?.remove();\n\n    Maplibre.savedMaps.push(this);\n  }\n\n  destroy() {\n    this._map.remove();\n  }\n\n  // Force redraw the map now. Typically resize() and jumpTo() is reflected in the next\n  // render cycle, which is managed by Mapbox's animation loop.\n  // This removes the synchronization issue caused by requestAnimationFrame.\n  redraw() {\n    const map = this._map as any;\n    // map._render will throw error if style does not exist\n    // https://github.com/mapbox/mapbox-gl-js/blob/fb9fc316da14e99ff4368f3e4faa3888fb43c513\n    //   /src/ui/map.js#L1834\n    if (map.style) {\n      // cancel the scheduled update\n      if (map._frame) {\n        map._frame.cancel();\n        map._frame = null;\n      }\n      // the order is important - render() may schedule another update\n      map._render();\n    }\n  }\n\n  /* Trigger map resize if size is controlled\n     @param {object} nextProps\n     @returns {bool} true if size has changed\n   */\n  private _updateSize(nextProps: MaplibreProps): boolean {\n    // Check if size is controlled\n    const {viewState} = nextProps;\n    if (viewState) {\n      const map = this._map;\n      if (viewState.width !== map.transform.width || viewState.height !== map.transform.height) {\n        map.resize();\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // Adapted from map.jumpTo\n  /* Update camera to match props\n     @param {object} nextProps\n     @param {bool} triggerEvents - should fire camera events\n     @returns {bool} true if anything is changed\n   */\n  private _updateViewState(nextProps: MaplibreProps): boolean {\n    const map = this._map;\n    const tr = map.transform;\n    const isMoving = map.isMoving();\n\n    // Avoid manipulating the real transform when interaction/animation is ongoing\n    // as it would interfere with Mapbox's handlers\n    if (!isMoving) {\n      const changes = applyViewStateToTransform(tr, nextProps);\n      if (Object.keys(changes).length > 0) {\n        this._internalUpdate = true;\n        map.jumpTo(changes);\n        this._internalUpdate = false;\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /* Update camera constraints and projection settings to match props\n     @param {object} nextProps\n     @param {object} currProps\n     @returns {bool} true if anything is changed\n   */\n  private _updateSettings(nextProps: MaplibreProps, currProps: MaplibreProps): boolean {\n    const map = this._map;\n    let changed = false;\n    for (const propName of settingNames) {\n      if (propName in nextProps && !deepEqual(nextProps[propName], currProps[propName])) {\n        changed = true;\n        const setter = map[`set${propName[0].toUpperCase()}${propName.slice(1)}`];\n        setter?.call(map, nextProps[propName]);\n      }\n    }\n    return changed;\n  }\n\n  /* Update map style to match props */\n  private _updateStyle(nextProps: MaplibreProps, currProps: MaplibreProps): void {\n    if (nextProps.cursor !== currProps.cursor) {\n      this._map.getCanvas().style.cursor = nextProps.cursor || '';\n    }\n    if (nextProps.mapStyle !== currProps.mapStyle) {\n      const {mapStyle = DEFAULT_STYLE, styleDiffing = true} = nextProps;\n      const options: any = {\n        diff: styleDiffing\n      };\n      if ('localIdeographFontFamily' in nextProps) {\n        // @ts-ignore Mapbox specific prop\n        options.localIdeographFontFamily = nextProps.localIdeographFontFamily;\n      }\n      this._map.setStyle(normalizeStyle(mapStyle), options);\n    }\n  }\n\n  /* Update fog, light, projection and terrain to match props\n   * These props are special because\n   * 1. They can not be applied right away. Certain conditions (style loaded, source loaded, etc.) must be met\n   * 2. They can be overwritten by mapStyle\n   */\n  private _updateStyleComponents({light, projection, sky, terrain}: MaplibreProps): void {\n    const map = this._map;\n    const currProps = this._styleComponents;\n    // We can safely manipulate map style once it's loaded\n    if (map.style._loaded) {\n      if (light && !deepEqual(light, currProps.light)) {\n        currProps.light = light;\n        map.setLight(light);\n      }\n      if (\n        projection &&\n        !deepEqual(projection, currProps.projection) &&\n        projection !== currProps.projection?.type\n      ) {\n        currProps.projection = typeof projection === 'string' ? {type: projection} : projection;\n        // @ts-ignore setProjection does not exist in v4\n        map.setProjection?.(currProps.projection);\n      }\n      if (sky && !deepEqual(sky, currProps.sky)) {\n        currProps.sky = sky;\n        map.setSky(sky);\n      }\n      if (terrain !== undefined && !deepEqual(terrain, currProps.terrain)) {\n        if (!terrain || map.getSource(terrain.source)) {\n          currProps.terrain = terrain;\n          map.setTerrain(terrain);\n        }\n      }\n    }\n  }\n\n  /* Update interaction handlers to match props */\n  private _updateHandlers(nextProps: MaplibreProps, currProps: MaplibreProps): void {\n    const map = this._map;\n    for (const propName of handlerNames) {\n      const newValue = nextProps[propName] ?? true;\n      const oldValue = currProps[propName] ?? true;\n      if (!deepEqual(newValue, oldValue)) {\n        if (newValue) {\n          map[propName].enable(newValue);\n        } else {\n          map[propName].disable();\n        }\n      }\n    }\n  }\n\n  private _onEvent = (e: MapEvent) => {\n    // @ts-ignore\n    const cb = this.props[otherEvents[e.type]];\n    if (cb) {\n      cb(e);\n    } else if (e.type === 'error') {\n      console.error((e as ErrorEvent).error); // eslint-disable-line\n    }\n  };\n\n  private _onCameraEvent = (e: ViewStateChangeEvent) => {\n    if (this._internalUpdate) {\n      return;\n    }\n    e.viewState = this._propsedCameraUpdate || transformToViewState(this._map.transform);\n    // @ts-ignore\n    const cb = this.props[cameraEvents[e.type]];\n    if (cb) {\n      cb(e);\n    }\n  };\n\n  private _onCameraUpdate = (tr: TransformLike) => {\n    if (this._internalUpdate) {\n      return tr;\n    }\n    this._propsedCameraUpdate = transformToViewState(tr);\n    return applyViewStateToTransform(tr, this.props);\n  };\n\n  private _queryRenderedFeatures(point: Point) {\n    const map = this._map;\n    const {interactiveLayerIds = []} = this.props;\n    try {\n      return map.queryRenderedFeatures(point, {\n        layers: interactiveLayerIds.filter(map.getLayer.bind(map))\n      });\n    } catch {\n      // May fail if style is not loaded\n      return [];\n    }\n  }\n\n  private _updateHover(e: MapMouseEvent) {\n    const {props} = this;\n    const shouldTrackHoveredFeatures =\n      props.interactiveLayerIds && (props.onMouseMove || props.onMouseEnter || props.onMouseLeave);\n\n    if (shouldTrackHoveredFeatures) {\n      const eventType = e.type;\n      const wasHovering = this._hoveredFeatures?.length > 0;\n      const features = this._queryRenderedFeatures(e.point);\n      const isHovering = features.length > 0;\n\n      if (!isHovering && wasHovering) {\n        e.type = 'mouseleave';\n        this._onPointerEvent(e);\n      }\n      this._hoveredFeatures = features;\n      if (isHovering && !wasHovering) {\n        e.type = 'mouseenter';\n        this._onPointerEvent(e);\n      }\n      e.type = eventType;\n    } else {\n      this._hoveredFeatures = null;\n    }\n  }\n\n  private _onPointerEvent = (e: MapMouseEvent) => {\n    if (e.type === 'mousemove' || e.type === 'mouseout') {\n      this._updateHover(e);\n    }\n\n    // @ts-ignore\n    const cb = this.props[pointerEvents[e.type]];\n    if (cb) {\n      if (this.props.interactiveLayerIds && e.type !== 'mouseover' && e.type !== 'mouseout') {\n        e.features = this._hoveredFeatures || this._queryRenderedFeatures(e.point);\n      }\n      cb(e);\n      delete e.features;\n    }\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}