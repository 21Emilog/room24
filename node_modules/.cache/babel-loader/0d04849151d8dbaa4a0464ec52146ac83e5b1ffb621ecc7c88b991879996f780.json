{"ast":null,"code":"/**\r\n * Compress and resize image file for optimal upload and storage\r\n * @param {File} file - Original image file\r\n * @param {Object} options - Compression options\r\n * @returns {Promise<string>} - Base64 encoded compressed image\r\n */\nexport function compressImage(file, options = {}) {\n  const {\n    maxWidth = 1200,\n    maxHeight = 1200,\n    quality = 0.8,\n    maxSizeKB = 500\n  } = options;\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.readAsDataURL(file);\n    reader.onload = event => {\n      const img = new Image();\n      img.src = event.target.result;\n      img.onload = () => {\n        const canvas = document.createElement('canvas');\n        let width = img.width;\n        let height = img.height;\n\n        // Calculate new dimensions\n        if (width > height) {\n          if (width > maxWidth) {\n            height = height * maxWidth / width;\n            width = maxWidth;\n          }\n        } else {\n          if (height > maxHeight) {\n            width = width * maxHeight / height;\n            height = maxHeight;\n          }\n        }\n        canvas.width = width;\n        canvas.height = height;\n        const ctx = canvas.getContext('2d');\n        ctx.drawImage(img, 0, 0, width, height);\n\n        // Try compression at specified quality\n        let compressedDataUrl = canvas.toDataURL('image/jpeg', quality);\n\n        // If still too large, reduce quality further\n        let currentQuality = quality;\n        while (compressedDataUrl.length / 1024 > maxSizeKB && currentQuality > 0.1) {\n          currentQuality -= 0.1;\n          compressedDataUrl = canvas.toDataURL('image/jpeg', currentQuality);\n        }\n        resolve(compressedDataUrl);\n      };\n      img.onerror = error => {\n        reject(new Error('Failed to load image'));\n      };\n    };\n    reader.onerror = error => {\n      reject(new Error('Failed to read file'));\n    };\n  });\n}\n\n/**\r\n * Get file size in KB from base64 string\r\n */\nexport function getBase64SizeKB(base64String) {\n  const stringLength = base64String.length - 'data:image/jpeg;base64,'.length;\n  const sizeInBytes = 4 * Math.ceil(stringLength / 3) * 0.5624896334383812;\n  return sizeInBytes / 1024;\n}","map":{"version":3,"names":["compressImage","file","options","maxWidth","maxHeight","quality","maxSizeKB","Promise","resolve","reject","reader","FileReader","readAsDataURL","onload","event","img","Image","src","target","result","canvas","document","createElement","width","height","ctx","getContext","drawImage","compressedDataUrl","toDataURL","currentQuality","length","onerror","error","Error","getBase64SizeKB","base64String","stringLength","sizeInBytes","Math","ceil"],"sources":["C:/Users/kutum/Documents/room-rental-platform/src/utils/imageCompression.js"],"sourcesContent":["/**\r\n * Compress and resize image file for optimal upload and storage\r\n * @param {File} file - Original image file\r\n * @param {Object} options - Compression options\r\n * @returns {Promise<string>} - Base64 encoded compressed image\r\n */\r\nexport function compressImage(file, options = {}) {\r\n  const {\r\n    maxWidth = 1200,\r\n    maxHeight = 1200,\r\n    quality = 0.8,\r\n    maxSizeKB = 500\r\n  } = options;\r\n\r\n  return new Promise((resolve, reject) => {\r\n    const reader = new FileReader();\r\n    reader.readAsDataURL(file);\r\n    \r\n    reader.onload = (event) => {\r\n      const img = new Image();\r\n      img.src = event.target.result;\r\n      \r\n      img.onload = () => {\r\n        const canvas = document.createElement('canvas');\r\n        let width = img.width;\r\n        let height = img.height;\r\n\r\n        // Calculate new dimensions\r\n        if (width > height) {\r\n          if (width > maxWidth) {\r\n            height = (height * maxWidth) / width;\r\n            width = maxWidth;\r\n          }\r\n        } else {\r\n          if (height > maxHeight) {\r\n            width = (width * maxHeight) / height;\r\n            height = maxHeight;\r\n          }\r\n        }\r\n\r\n        canvas.width = width;\r\n        canvas.height = height;\r\n\r\n        const ctx = canvas.getContext('2d');\r\n        ctx.drawImage(img, 0, 0, width, height);\r\n\r\n        // Try compression at specified quality\r\n        let compressedDataUrl = canvas.toDataURL('image/jpeg', quality);\r\n        \r\n        // If still too large, reduce quality further\r\n        let currentQuality = quality;\r\n        while (compressedDataUrl.length / 1024 > maxSizeKB && currentQuality > 0.1) {\r\n          currentQuality -= 0.1;\r\n          compressedDataUrl = canvas.toDataURL('image/jpeg', currentQuality);\r\n        }\r\n\r\n        resolve(compressedDataUrl);\r\n      };\r\n\r\n      img.onerror = (error) => {\r\n        reject(new Error('Failed to load image'));\r\n      };\r\n    };\r\n\r\n    reader.onerror = (error) => {\r\n      reject(new Error('Failed to read file'));\r\n    };\r\n  });\r\n}\r\n\r\n/**\r\n * Get file size in KB from base64 string\r\n */\r\nexport function getBase64SizeKB(base64String) {\r\n  const stringLength = base64String.length - 'data:image/jpeg;base64,'.length;\r\n  const sizeInBytes = 4 * Math.ceil(stringLength / 3) * 0.5624896334383812;\r\n  return sizeInBytes / 1024;\r\n}\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASA,aAAaA,CAACC,IAAI,EAAEC,OAAO,GAAG,CAAC,CAAC,EAAE;EAChD,MAAM;IACJC,QAAQ,GAAG,IAAI;IACfC,SAAS,GAAG,IAAI;IAChBC,OAAO,GAAG,GAAG;IACbC,SAAS,GAAG;EACd,CAAC,GAAGJ,OAAO;EAEX,OAAO,IAAIK,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;IACtC,MAAMC,MAAM,GAAG,IAAIC,UAAU,CAAC,CAAC;IAC/BD,MAAM,CAACE,aAAa,CAACX,IAAI,CAAC;IAE1BS,MAAM,CAACG,MAAM,GAAIC,KAAK,IAAK;MACzB,MAAMC,GAAG,GAAG,IAAIC,KAAK,CAAC,CAAC;MACvBD,GAAG,CAACE,GAAG,GAAGH,KAAK,CAACI,MAAM,CAACC,MAAM;MAE7BJ,GAAG,CAACF,MAAM,GAAG,MAAM;QACjB,MAAMO,MAAM,GAAGC,QAAQ,CAACC,aAAa,CAAC,QAAQ,CAAC;QAC/C,IAAIC,KAAK,GAAGR,GAAG,CAACQ,KAAK;QACrB,IAAIC,MAAM,GAAGT,GAAG,CAACS,MAAM;;QAEvB;QACA,IAAID,KAAK,GAAGC,MAAM,EAAE;UAClB,IAAID,KAAK,GAAGpB,QAAQ,EAAE;YACpBqB,MAAM,GAAIA,MAAM,GAAGrB,QAAQ,GAAIoB,KAAK;YACpCA,KAAK,GAAGpB,QAAQ;UAClB;QACF,CAAC,MAAM;UACL,IAAIqB,MAAM,GAAGpB,SAAS,EAAE;YACtBmB,KAAK,GAAIA,KAAK,GAAGnB,SAAS,GAAIoB,MAAM;YACpCA,MAAM,GAAGpB,SAAS;UACpB;QACF;QAEAgB,MAAM,CAACG,KAAK,GAAGA,KAAK;QACpBH,MAAM,CAACI,MAAM,GAAGA,MAAM;QAEtB,MAAMC,GAAG,GAAGL,MAAM,CAACM,UAAU,CAAC,IAAI,CAAC;QACnCD,GAAG,CAACE,SAAS,CAACZ,GAAG,EAAE,CAAC,EAAE,CAAC,EAAEQ,KAAK,EAAEC,MAAM,CAAC;;QAEvC;QACA,IAAII,iBAAiB,GAAGR,MAAM,CAACS,SAAS,CAAC,YAAY,EAAExB,OAAO,CAAC;;QAE/D;QACA,IAAIyB,cAAc,GAAGzB,OAAO;QAC5B,OAAOuB,iBAAiB,CAACG,MAAM,GAAG,IAAI,GAAGzB,SAAS,IAAIwB,cAAc,GAAG,GAAG,EAAE;UAC1EA,cAAc,IAAI,GAAG;UACrBF,iBAAiB,GAAGR,MAAM,CAACS,SAAS,CAAC,YAAY,EAAEC,cAAc,CAAC;QACpE;QAEAtB,OAAO,CAACoB,iBAAiB,CAAC;MAC5B,CAAC;MAEDb,GAAG,CAACiB,OAAO,GAAIC,KAAK,IAAK;QACvBxB,MAAM,CAAC,IAAIyB,KAAK,CAAC,sBAAsB,CAAC,CAAC;MAC3C,CAAC;IACH,CAAC;IAEDxB,MAAM,CAACsB,OAAO,GAAIC,KAAK,IAAK;MAC1BxB,MAAM,CAAC,IAAIyB,KAAK,CAAC,qBAAqB,CAAC,CAAC;IAC1C,CAAC;EACH,CAAC,CAAC;AACJ;;AAEA;AACA;AACA;AACA,OAAO,SAASC,eAAeA,CAACC,YAAY,EAAE;EAC5C,MAAMC,YAAY,GAAGD,YAAY,CAACL,MAAM,GAAG,yBAAyB,CAACA,MAAM;EAC3E,MAAMO,WAAW,GAAG,CAAC,GAAGC,IAAI,CAACC,IAAI,CAACH,YAAY,GAAG,CAAC,CAAC,GAAG,kBAAkB;EACxE,OAAOC,WAAW,GAAG,IAAI;AAC3B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}