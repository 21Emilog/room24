{"version":3,"sources":["service-worker.js"],"names":["PRECACHE_MANIFEST","self","__WB_MANIFEST","SHELL_CACHE","RUNTIME_IMG_CACHE","MAP_TILE_HOST_PATTERNS","addEventListener","event","waitUntil","caches","open","then","cache","Promise","all","map","entry","url","add","skipWaiting","keys","filter","k","includes","delete","clients","claim","request","method","URL","origin","location","respondWith","match","cached","fetch","isImage","destination","isMapTile","some","host","response","status","put","clone","catch","Response","error"],"mappings":"MAMA,MAAM,EAAoB,iOAAK,eAAiB,GAC1C,EAAc,kBACd,EAAoB,wBACpB,EAAyB,CAC7B,yBACA,wBAGF,KAAK,iBAAiB,UAAW,IAC/B,EAAM,UACJ,OAAO,KAAK,GAAa,KAAK,GACrB,QAAQ,IACb,EAAkB,IAAI,IACpB,MAAM,EAAM,EAAM,KAAO,EACzB,OAAO,EAAM,IAAI,OAGpB,KAAK,IAAM,KAAK,kBAIvB,KAAK,iBAAiB,WAAY,IAChC,EAAM,UACJ,OAAO,OAAO,KAAK,GAAQ,QAAQ,IACjC,EAAK,OAAO,IAAM,CAAC,EAAa,GAAmB,SAAS,IAAI,IAAI,GAAK,OAAO,OAAO,MACtF,KAAK,IAAM,KAAK,QAAQ,YAI/B,KAAK,iBAAiB,QAAS,IAC7B,MAAM,QAAE,GAAY,EACpB,GAAuB,QAAnB,EAAQ,OAAkB,OAC9B,MAAM,EAAM,IAAI,IAAI,EAAQ,KAG5B,GAAI,EAAI,SAAW,KAAK,SAAS,OAI/B,YAHA,EAAM,YACJ,OAAO,MAAM,GAAS,KAAK,GAAU,GAAU,MAAM,KAMzD,MAAM,EAAkC,UAAxB,EAAQ,YAClB,EAAY,EAAuB,KAAK,GAAQ,EAAI,KAAK,SAAS,IAEpE,GAAW,EACb,EAAM,YACJ,OAAO,KAAK,GAAmB,KAAK,GAAS,EAAM,MAAM,GAAS,KAAK,GACjE,GACG,MAAM,GAAS,KAAK,IACD,MAApB,EAAS,QAAgB,EAAM,IAAI,EAAS,EAAS,SAClD,IACN,MAAM,IAAM,GAAU,SAAS,YAOxC,EAAM,YACJ,MAAM,GAAS,MAAM,IAAM,OAAO,MAAM","file":"service-worker.js","sourceRoot":"","sourcesContent":["/* eslint-disable no-restricted-globals */\r\n/*\r\n  Room24 service worker leveraging CRA Workbox injection point.\r\n  Workbox will replace self.__WB_MANIFEST with a list of build assets.\r\n*/\r\n\r\nconst PRECACHE_MANIFEST = self.__WB_MANIFEST || [];\r\nconst SHELL_CACHE = 'room24-shell-v1';\r\nconst RUNTIME_IMG_CACHE = 'room24-img-runtime-v1';\r\nconst MAP_TILE_HOST_PATTERNS = [\r\n  'tile.openstreetmap.org',\r\n  'tiles.stadiamaps.com'\r\n];\r\n\r\nself.addEventListener('install', event => {\r\n  event.waitUntil(\r\n    caches.open(SHELL_CACHE).then(cache => {\r\n      return Promise.all(\r\n        PRECACHE_MANIFEST.map(entry => {\r\n          const url = entry.url || entry; // Workbox entries have url property\r\n          return cache.add(url);\r\n        })\r\n      );\r\n    }).then(() => self.skipWaiting())\r\n  );\r\n});\r\n\r\nself.addEventListener('activate', event => {\r\n  event.waitUntil(\r\n    caches.keys().then(keys => Promise.all(\r\n      keys.filter(k => ![SHELL_CACHE, RUNTIME_IMG_CACHE].includes(k)).map(k => caches.delete(k))\r\n    )).then(() => self.clients.claim())\r\n  );\r\n});\r\n\r\nself.addEventListener('fetch', event => {\r\n  const { request } = event;\r\n  if (request.method !== 'GET') return;\r\n  const url = new URL(request.url);\r\n\r\n  // Same-origin: try cache first for precached shell/static assets\r\n  if (url.origin === self.location.origin) {\r\n    event.respondWith(\r\n      caches.match(request).then(cached => cached || fetch(request))\r\n    );\r\n    return;\r\n  }\r\n\r\n  // Runtime caching for images & map tiles\r\n  const isImage = request.destination === 'image';\r\n  const isMapTile = MAP_TILE_HOST_PATTERNS.some(host => url.host.includes(host));\r\n\r\n  if (isImage || isMapTile) {\r\n    event.respondWith(\r\n      caches.open(RUNTIME_IMG_CACHE).then(cache => cache.match(request).then(cached => {\r\n        if (cached) return cached;\r\n        return fetch(request).then(response => {\r\n          if (response.status === 200) cache.put(request, response.clone());\r\n          return response;\r\n        }).catch(() => cached || Response.error());\r\n      }))\r\n    );\r\n    return;\r\n  }\r\n\r\n  // Default network-first strategy\r\n  event.respondWith(\r\n    fetch(request).catch(() => caches.match(request))\r\n  );\r\n});\r\n"]}